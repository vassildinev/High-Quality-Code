# Behavioral Design Patterns
****
### Strategy Pattern

**Кратко описание**

Да се дефинират взаимно заменяеми алгоритми, които решават един и същ проблем, но по различни начини, позволявайки да променяме поведението на обекта, който ги използва, без да променяме самия него.

**Приложение**

Той намира приложение в следните най-често срещани ситуации:
 * Ако имаме много класове, които решават един и същ проблем, но по различни начини. "Стратегия" (Strategy) ни дава възможност да ги използваме от един клас, като променяме поведението му по време на изпълнение на програмата.
 * Имаме клас, който променя поведението си в зависимост от даден параметър, чрез употребата на много условни конструкции. Можем да заместим всяка такава конструкция със стратегия.
 * В даден клас имаме прекалено много структури и логика, свързани с алгоритъм, изпълняващ се в класа. "Стратегия" (Strategy) ни позволява да отделим и скрием тези подробности в отделен клас.
 * Имаме клас, който има няколко начина на поведение и не ни е известно по време на компилация кой от тях трябва да използваме. Чрез "Стратегия" (Strategy) можем да вземем това решение по време на изпълнение на програмата.

**Структура на шаблона**

![](http://www.dofactory.com/images/diagrams/net/strategy.gif)

**Участници**

 * Стратегия (Strategy). Декларира общ интерфейс за всички поддържани алгоритми (стратегии). Контекстът (Context) се обръща към този интерфейс, за да използва дадена конкретна имплементация (ConcreteStrategy).
 * Конкретна стратегия (ConcreteStrategy). Имплементира интерфейса Strategy, реализирайки конкретен алгоритъм (стратегия).
 * Контекст (Context). Конфигуриран е с подходяща инстанция на клас от тип Стратегия (Strategy), тоест държи референция към такъв клас.

**Пример**

![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/StrategyPattern_IBrakeBehavior.svg/400px-StrategyPattern_IBrakeBehavior.svg.png)

**Свързани шаблони**
 * Flyweight

***

### Command Pattern

**Кратко описание**

В основата на шаблона седи обектът команда, който капсулира извикването на даден метод. Целта е да се отдели логиката, която предизвиква дадено действие, от логиката по неговото изпълнение.

**Приложение**

Той намира приложение в следните най-често срещани ситуации:
 * За разработка на класове за общо ползване, които да знаят само за причината, предизвикваща дадено действие, но не и какво прави то. Например, части от графичен интерфейс на приложение, като бутон или картинка, които да извикват дадена команда при щракне с мишката върху тях.
 * На командите може да се гледа и като на обектния еквивалент на "обратните извиквания" (callbacks). Те могат да бъдат предавани като параметър на обект, който да се погрижи за тяхното изпълнение в по-късен момент. 
 * Командите могат да бъдат съхранявани в опашка и изпълнявани в по-късен момент. Така обработката на дадена заявка, капсулирана в обекти от тип "команда", става независима от продължителността на съществуване на самата заявка.
 * За имплементирането на отмяна на операции (undo) и повторно изпълняване на отменени операции (redo). В този случай, в командите е необходимо да се съхранява и необходимата информация за отмяна на операцията.
 * При нужда от регистриране (logging) или контролиране на промените над даден обект, така че те да могат да бъдат изпълнени отново в случай на внезапен срив на системата.
 * Шаблонът позволява дефинирането на композитни (макро) команди, чието изпълнение е поредица от изпълненията на няколко други команди, включително и композитни такива. Композитните команди имплементират същия интерфейс като обикновените команди и това ни позволява лесно и бързо да комбинираме и преизползваме вече съществуващи команди, за да създаваме нови. 
 * Командите ни дават възможност да представяме последователност от премени в състоянието на обекти в системата. С тях работим, използвайки единен интерфейс, можем да ги групираме и да подсигуряваме тяхното атомарно изпълнение. Затова шаблонът често се използва в системи, нуждаещи се от поддръжка на транзакции.

**Структура на шаблона**

![](http://www.dofactory.com/images/diagrams/net/command.gif)

**Участници**

 * Команда (Command) 
Това е базовият интерфейс на командата.
 * Конкретна команда (Concrete Command)
Това са различните имплементации на Command.
 * Получател (Receiver)
Това е класът, който знае как да изпълни конкретните операции, стоящи зад дадена команда.
 * Инициатор (Invoker)
Инициаторът предизвиква изпълнението на командата, когато това е необходимо.
 * Клиент (Client)
Това е класът, отговорен за създаването на различните конкретни команди, като им подава получател и друга, необходима им информация. Този клас често е отговорен и за подаването на тези команди на класа инициатор (Invoker).

**Пример**

![](http://www.dotnet-tricks.com/Content/images/designpatterns/command1.png)

**Свързани шаблони**
 * Composite
 * Memento
 * Prototype

***
**Източници**

Google, Wikipedia, http://www.nakov.com/blog/2011/12/27/free-bulgarian-design-patterns-book/ - Класически шаблони за дизайн
***