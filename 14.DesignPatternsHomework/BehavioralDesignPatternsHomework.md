# Behavioral Design Patterns
****
### Strategy Pattern

**Кратко описание**

Да се дефинират взаимно заменяеми алгоритми, които решават един и същ проблем, но по различни начини, позволявайки да променяме поведението на обекта, който ги използва, без да променяме самия него.

**Приложение**

Той намира приложение в следните най-често срещани ситуации:
 * Ако имаме много класове, които решават един и същ проблем, но по различни начини. "Стратегия" (Strategy) ни дава възможност да ги използваме от един клас, като променяме поведението му по време на изпълнение на програмата.
 * Имаме клас, който променя поведението си в зависимост от даден параметър, чрез употребата на много условни конструкции. Можем да заместим всяка такава конструкция със стратегия.
 * В даден клас имаме прекалено много структури и логика, свързани с алгоритъм, изпълняващ се в класа. "Стратегия" (Strategy) ни позволява да отделим и скрием тези подробности в отделен клас.
 * Имаме клас, който има няколко начина на поведение и не ни е известно по време на компилация кой от тях трябва да използваме. Чрез "Стратегия" (Strategy) можем да вземем това решение по време на изпълнение на програмата.

**Структура на шаблона**

![](http://www.dofactory.com/images/diagrams/net/strategy.gif)

**Участници**

 * Стратегия (Strategy). Декларира общ интерфейс за всички поддържани алгоритми (стратегии). Контекстът (Context) се обръща към този интерфейс, за да използва дадена конкретна имплементация (ConcreteStrategy).
 * Конкретна стратегия (ConcreteStrategy). Имплементира интерфейса Strategy, реализирайки конкретен алгоритъм (стратегия).
 * Контекст (Context). Конфигуриран е с подходяща инстанция на клас от тип Стратегия (Strategy), тоест държи референция към такъв клас.

**Пример**

![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/StrategyPattern_IBrakeBehavior.svg/400px-StrategyPattern_IBrakeBehavior.svg.png)

**Свързани шаблони**
 * Flyweight

***

### Command Pattern

**Кратко описание**

В основата на шаблона седи обектът команда, който капсулира извикването на даден метод. Целта е да се отдели логиката, която предизвиква дадено действие, от логиката по неговото изпълнение.

**Приложение**

Той намира приложение в следните най-често срещани ситуации:
 * За разработка на класове за общо ползване, които да знаят само за причината, предизвикваща дадено действие, но не и какво прави то. Например, части от графичен интерфейс на приложение, като бутон или картинка, които да извикват дадена команда при щракне с мишката върху тях.
 * На командите може да се гледа и като на обектния еквивалент на "обратните извиквания" (callbacks). Те могат да бъдат предавани като параметър на обект, който да се погрижи за тяхното изпълнение в по-късен момент. 
 * Командите могат да бъдат съхранявани в опашка и изпълнявани в по-късен момент. Така обработката на дадена заявка, капсулирана в обекти от тип "команда", става независима от продължителността на съществуване на самата заявка.
 * За имплементирането на отмяна на операции (undo) и повторно изпълняване на отменени операции (redo). В този случай, в командите е необходимо да се съхранява и необходимата информация за отмяна на операцията.
 * При нужда от регистриране (logging) или контролиране на промените над даден обект, така че те да могат да бъдат изпълнени отново в случай на внезапен срив на системата.
 * Шаблонът позволява дефинирането на композитни (макро) команди, чието изпълнение е поредица от изпълненията на няколко други команди, включително и композитни такива. Композитните команди имплементират същия интерфейс като обикновените команди и това ни позволява лесно и бързо да комбинираме и преизползваме вече съществуващи команди, за да създаваме нови. 
 * Командите ни дават възможност да представяме последователност от премени в състоянието на обекти в системата. С тях работим, използвайки единен интерфейс, можем да ги групираме и да подсигуряваме тяхното атомарно изпълнение. Затова шаблонът често се използва в системи, нуждаещи се от поддръжка на транзакции.

**Структура на шаблона**

![](http://www.dofactory.com/images/diagrams/net/command.gif)

**Участници**

 * Команда (Command) 
Това е базовият интерфейс на командата.
 * Конкретна команда (Concrete Command)
Това са различните имплементации на Command.
 * Получател (Receiver)
Това е класът, който знае как да изпълни конкретните операции, стоящи зад дадена команда.
 * Инициатор (Invoker)
Инициаторът предизвиква изпълнението на командата, когато това е необходимо.
 * Клиент (Client)
Това е класът, отговорен за създаването на различните конкретни команди, като им подава получател и друга, необходима им информация. Този клас често е отговорен и за подаването на тези команди на класа инициатор (Invoker).

**Пример**

![](http://www.dotnet-tricks.com/Content/images/designpatterns/command1.png)

**Свързани шаблони**
 * Composite
 * Memento
 * Prototype

***

### Observer Pattern

**Кратко описание**

Определя връзката "едно-към-много" между обекти. Когато един обект промени своето състояние, всички зависими от него обекти биват известени автоматично и могат да предприемат необходими действия.

**Приложение**

Той намира приложение в следните най-често срещани ситуации:
 * когато имаме две страни, като едната страна зависи от другата;
 * промяна на един обект изисква промяна и на други обекти;
 * един обект трябва да може да известява други обекти.
 * Обектът, който променя/известява зависимите от него обекти, не се интересува колко и кои са те. Така се постига слаба свързаност на двете страни (loose coupling) — те са независими една от друга, имат ясно определени отговорности, лесно могат да бъдат променяни и преизползвани.

**Структура на шаблона**

![](http://www.codeproject.com/KB/architecture/457472/ObserverPatternOMT.JPG)

**Участници**

 * Наблюдаван обект (subject, observable) 
    знае своите наблюдатели;
    дефинира интерфейс за регистриране, известяване и отписване на наблюдатели.
 * Наблюдател (observer)
   дефинира интерфейс за обновяване на обекти, които искат да бъдат известени при промяна състоянието на наблюдавания обект.
 * Конкретен наблюдаван обект (concrete subject)
   пази своето състояние (или само онази част от състоянието си, от която наблюдателите се интересуват);
   изпраща известие на своите наблюдатели, когато настъпи промяна в състоянието му;
 * Конкретен наблюдател (concrete observer)
   пази референция към конкретен наблюдаван обект (concrete subject обект);
   пази свое състояние, като се стреми то винаги да бъде съгласувано със състоянието на наблюдавания обект;
   имплементира протокола за обновяване, дефиниран в наблюдателя (observer).
 * Двата участника - наблюдаван обект (subject) и наблюдател (observer), при реализация се представят най-често като абстрактен клас или интерфейс. Така се въвежда ниво на абстракция, където декларираме базовите функционалности (операции), които очакваме всеки от тях да изпълнява. След това може да създадем произволен брой конкретни имплементации.


**Пример**

![](http://i1.code.msdn.s-msft.com/design-pattern-concepts-feba4faf/image/file/75954/1/cdobserverdp.png)

**Свързани шаблони**
 * Template method
 * Mediator
 * Singleton

***
**Източници**

Google, Wikipedia, http://www.nakov.com/blog/2011/12/27/free-bulgarian-design-patterns-book/ - Класически шаблони за дизайн
***