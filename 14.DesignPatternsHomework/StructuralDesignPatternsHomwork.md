# Structural Design Patterns
****
### Bridge Pattern

**Кратко описание**

Основната цел на шаблона е да раздели дадена абстракция от нейната конкретна имплементация така, че да може да се правят независими промени и в двете без това да влияе на клиентите.

**Приложение**

Той намира приложение в следните най-често срещани ситуации:
 - когато искаме да избегнем обвързването между абстракция и конкретна имплементация. По този начин имаме възможността да изберем или да променим имплементацията по време на изпълнение.
 - когато промяната в избора на имплементацията не трябва да има влияние върху клиентите – т.е. да не се налага те да променят или да прекомпилират своя код.
 - когато абстракцията и имплементацията използвана от нея трябва да могат да бъдат разширявани (extended) в свои отделни йерархии. В този случай шаблонът Bridge дава свободата да се комбинират конкретните подкласове на абстракцията с конкретните подкласове на имплементацията в зависимост от нуждите ни.
 - когато се налага споделяне на една имплементация сред много обекти и това трябва да остане скрито от клиентите.
 - когато имаме две йерархии от класове, които си приличат или споделят общи данни и които са оплетени в една – в този случай шаблона помага да ги разделим ясно като отделим едната, която е по-близка до имплементационнит детайли и не бива да се достъпва от клиентите в отделна йерархия.

**Структура на шаблона**

![](http://www.dofactory.com/images/diagrams/net/bridge.gif)

**Участници**

 - Абстракция (Abstraction) – Дефинира интерфейс на абстракцията. Това е класът или интерфейсът, с който клиентите ще си взаимодействат. Освен това съдържа в себе си референция към конкретната имплементация, която ще се използва, препращайки определени команди към нея.
 - Специализирана абстракция (Refined Abstraction) – Имплементира интерфейса или абстрактният клас предоставен от абстракцията.
 - Имплементация (Implementor) – Дефинира интерфейс за имплементацията. Има възможност той да бъде различен от интерфейса на абстракцията. Клиентите не би трябвало да имат достъп до този интерфейс, а да си взаимодействат с абстракцията или някоя разширена абстракция.
 - Конкретна имплементация (ConcreteImplementor) – задава конкретна имплементация на горния интерфейс. 

**Пример**

![](http://www.joezimjs.com/wp-content/uploads/bridge_remote.png)

**Свързани шаблони**
 - Abstract Factory
 - Adapter
 - State
 - Strategy

***
### Facade Pattern

**Кратко описание**

Целта на шаблона Facade е да предостави опростен интерфейс за взаимодействие със сложна подсистема или множество подсистеми.

**Приложение**

Шаблонът Facade може да се използва в следните случаи:
 - Нужда от опростен интерфейс към сложна система – създаването на фасада, даваща достъп на клиентите само до нужната им функционалност скрива от тях сложността на системата.
 - При наличие на твърде голяма зависимост между клиентите и кон-кретните имплементации на дадена абстракция – в този случай поставянето на фасада между клиентите и имплементацията премахва директната зависимост между тях. 
 - При нужда от разделяне на системата на слоеве – можем да разделим монолитна системата на отделни слоеве даващи достъп до определена функционалност чрез дефинирането на отделна фасада за всеки от тях.
 - Нужда от опростяване на комуникациите между клиента и обектите на системата – ако получаването на резултат изисква няколко операции върху данните, то фасадата може да предостави метод приемащ данните и връщаш резултата, поемайки задачата за извикването на необходимите междинни операции. 


**Структура на шаблона**

![](http://4.bp.blogspot.com/-W6xz6EFoXxA/VKVX38_E7cI/AAAAAAAACT0/t6AgrjrF4xI/s1600/facade%2Bpattern%2Bin%2BJava.png)

**Участници**

При реализацията на шаблона имаме един или повече клиенти, които взаимодействат с класовете на подсистемата посредством интерфейсът предоставен от фасадата:

Клиент (Client)
 - Това е класът, който се нуждае от взаимодействие с класовете на подсистемата
 - Взаимодейства с интерфейса на фасадата вместо да достъпва директно класовете на подсистемата, които предоставят нужната му функционалност
 - С една фасада може да взаимодейства повече от един клиент

Фасада (Facade)
 - Предоставя опростен интерфейс към подсистемата
 - Познава вътрешната структура, класовете и връзките помежду им и знае как да взаимодейства с тях
 - Препраща клиентските заявки за изпълнение към подходящи обекти на подсистемата

Класове на подсистемата (Subsystem classes)
 - Дават достъп до различните функционалности на подсистемата
 - Изпълняват заявките изпратени от фасадата
 - Не зависят от фасадата и не знаят за нейното съществуване


**Пример**

![](http://www.tutorialspoint.com/design_pattern/images/facade_pattern_uml_diagram.jpg)

**Свързани шаблони**
 - Abstract Factory
 - Singleton

***

### Decorator Pattern

**Кратко описание**

Декораторът добавя функционалност към даден обект динамично. Шаблонът се използва като алтернатива на наследяването.

**Приложение**

Шаблонът "Декоратор" (Decorator) е полезен в ситуациите когато:
 - Искаме да добавим отговорност към обект динамично, без да променяме класа на обекта, т.е. без да изискваме промяна на всички инстанции на класа.
 - Искаме да отменим отговорност (свойства и поведение).
 - Използването на наследяване е непрактично. Например, много на брой функционалности могат да бъдат комбинирани независимо една от друга, което води до огромен брой подкласове. Друг пример е ситуация, в която даден клас е недостъпен за наследяване.


**Структура на шаблона**

![](http://www.php5dp.com/wp-content/uploads/2010/04/decoratorsmall1.png)

**Участници**

Шаблонът се състои от четири участника: Компонент (Component), Конкретен компонент (Concrete Component), Декоратор (Decorator), Конкретен декоратор (Concrete Decorator). Следващият списък описва всеки от изброените класове:
 - Компонент (Component)
Участникът Компонент (Component) дефинира интерфейса на декоратора и декорирания обект. Той може да бъде както интерфейс, така и абстрактен клас.
 - Конкретен компонент (Concrete Component)
Конкретният компонент (Concrete Component) дефинира обект, към който ще бъде добавена функционалност динамично. 
 - Декоратор (Decorator)
Декоратор (Decorator) е абстрактен клас, който наследява Компонент (Component) и вътрешно държи инстанция от същия тип. Основната функция на този клас е да пренасочва заявките на клиента към обвития обект от тип Компонент (Component).
 - Конкретен декоратор (Concrete Decorator)
Конкретният декоратор е наследник на Декоратор (Decorator), който добавя желаната функционалност към декорирания обект. 

**Пример**

![](http://www.codeproject.com/KB/architecture/468951/DecoratorDesignPatternExample.gif)

**Свързани шаблони**
 - Adapter
 - Composition
 - Strategy
 - Proxy

***
**Източници**

Google, Wikipedia, http://www.nakov.com/blog/2011/12/27/free-bulgarian-design-patterns-book/ - Класически шаблони за дизайн
***